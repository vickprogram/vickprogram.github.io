<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Responsive Polyomino Canvas</title>
  <style>
    * { box-sizing: border-box; margin:0; padding:0; }
    body { display: flex; flex-wrap: wrap; font-family: sans-serif; height:100vh; overflow:hidden; }
    #canvas-container { flex:1; position:relative; touch-action: none; }
    canvas { background:#fff; display:block; width:100%; height:100%; }
    .slider-container {
      background:#f8f8f8;
      padding:10px;
      overflow-y:auto;
      display:flex; flex-direction:column; gap:15px;
    }
    .slider { display:flex; flex-direction:column; }
    .label { font-size:14px; margin-bottom:4px; }
    .info { font-size:16px; }

    @media (min-width: 600px) {
      #canvas-container { order:0; width:75%; }
      .slider-container { order:1; width:25%; max-width:300px; height:100vh; }
    }
    @media (max-width: 599px) {
      .slider-container { order:0; width:100%; max-height:200px; flex-direction:row; overflow-x:auto; }
      .slider { min-width:150px; }
      #canvas-container { order:1; width:100%; height:calc(100vh - 200px); }
    }
  </style>
</head>
<body>
  <div class="slider-container">
    <div class="slider">
      <div class="label">p (hor leg): <span id="pVal">3</span></div>
      <input type="range" id="sliderP" min="2" max="10" value="3">
    </div>
    <div class="slider">
      <div class="label">q (ver leg): <span id="qVal">2</span></div>
      <input type="range" id="sliderQ" min="2" max="10" value="2">
    </div>
    <div class="slider">
      <div class="label">Pieces: <span id="nVal">4</span></div>
      <input type="range" id="sliderN" min="1" max="40" value="4">
    </div>
    <div class="info">Enclosed Area: <span id="areaVal">0</span></div>
  </div>
  <div id="canvas-container">
    <canvas id="gameCanvas"></canvas>
  </div>

<script>
  const cols = 30, rows = 30, rackCols = 14, piecesPerRow = 5;
  let gridSize, rackWidth, gridWidth, gridHeight;
  let pVal=3, qVal=2, nVal=4;
  let polys = [];
  let clickTimer = null, moved = false;
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const sliderP = document.getElementById('sliderP');
  const sliderQ = document.getElementById('sliderQ');
  const sliderN = document.getElementById('sliderN');
  const pValEl = document.getElementById('pVal');
  const qValEl = document.getElementById('qVal');
  const nValEl = document.getElementById('nVal');
  const areaValEl = document.getElementById('areaVal');

  class Polyomino {
    constructor(blocks,color){
      this.blocks=blocks; this.color=color;
      this.pos={x:0,y:0}; this.lastPos={x:0,y:0};
      this.dragging=false;
    }
    draw(){
      ctx.fillStyle=this.color; ctx.strokeStyle='#000';
      this.blocks.forEach(({x:bx,y:by})=>{
        const px = this.pos.x < rackCols
          ? this.pos.x*gridSize
          : rackWidth + (this.pos.x-rackCols)*gridSize;
        const py = this.pos.y*gridSize;
        ctx.fillRect(px+bx*gridSize, py+by*gridSize, gridSize, gridSize);
        ctx.strokeRect(px+bx*gridSize, py+by*gridSize, gridSize, gridSize);
      });
    }
    contains(x,y){
      return this.blocks.some(b=>b.x+this.pos.x===x && b.y+this.pos.y===y);
    }
    rotate(){
      let nb = this.blocks.map(({x,y})=>({x:y,y:-x}));
      const minX=Math.min(...nb.map(b=>b.x)), minY=Math.min(...nb.map(b=>b.y));
      this.blocks = nb.map(b=>({x:b.x-minX,y:b.y-minY}));
    }
    flip(){
      let nb = this.blocks.map(({x,y})=>({x:-x,y}));
      const minX=Math.min(...nb.map(b=>b.x)), minY=Math.min(...nb.map(b=>b.y));
      this.blocks = nb.map(b=>({x:b.x-minX,y:b.y-minY}));
    }
    getCells(){
      return this.blocks.map(b=>({x:this.pos.x+b.x, y:this.pos.y+b.y}));
    }
  }

  function createL(p,q){
    const arr=[];
    for(let i=0;i<p;i++) arr.push({x:i,y:0});
    for(let j=1;j<q;j++) arr.push({x:0,y:j});
    return arr;
  }

  function resetPieces(){
    polys=[];
    for(let i=0;i<nVal;i++){
      const blocks=createL(pVal,qVal);
      const color=\`rgb(\${100+Math.random()*155},\${100+Math.random()*155},\${100+Math.random()*155})\`;
      const poly=new Polyomino(blocks,color);
      poly.pos={x:i%piecesPerRow, y:Math.floor(i/piecesPerRow)};
      poly.lastPos={...poly.pos};
      polys.push(poly);
    }
  }

  function computeEnclosedArea(){
    const grid = Array(rows).fill().map(()=>Array(cols).fill(0));
    polys.forEach(poly=>{
      poly.getCells().forEach(c=>{
        if(c.x>=rackCols && c.x<rackCols+cols && c.y>=0 && c.y<rows) {
          grid[c.y][c.x-rackCols]=1;
        }
      });
    });
    const vis = grid.map(r=>r.map(()=>false));
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    const q=[];
    for(let x=0;x<cols;x++){
      [[0,x],[rows-1,x]].forEach(([r,c])=>{
        if(!grid[r][c] && !vis[r][c]) { vis[r][c]=true; q.push([c,r]); }
      });
    }
    for(let y=0;y<rows;y++){
      [[y,0],[y,cols-1]].forEach(([r,c])=>{
        if(!grid[r][c] && !vis[r][c]) { vis[r][c]=true; q.push([c,r]); }
      });
    }
    while(q.length){
      const [cx,cy]=q.shift();
      dirs.forEach(([dx,dy])=>{
        const nx=cx+dx, ny=cy+dy;
        if(nx>=0&&nx<cols&&ny>=0&&ny<rows && !grid[ny][nx] && !vis[ny][nx]){
          vis[ny][nx]=true; q.push([nx,ny]);
        }
      });
    }
    let area=0;
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        if(!vis[r][c] && grid[r][c]===0) area++;
      }
    }
    return area;
  }

  [sliderP,sliderQ,sliderN].forEach(sl=>{
    sl.addEventListener('input', ()=>{
      pVal=+sliderP.value; qVal=+sliderQ.value; nVal=+sliderN.value;
      pValEl.textContent=pVal; qValEl.textContent=qVal; nValEl.textContent=nVal;
      resetPieces();
    });
  });

  function getCellFromEvent(e){
    const rect=canvas.getBoundingClientRect();
    const cx = (e.touches? e.touches[0].clientX : e.clientX) - rect.left;
    const cy = (e.touches? e.touches[0].clientY : e.clientY) - rect.top;
    const cellX = cx < rackWidth
      ? Math.floor(cx/gridSize)
      : rackCols + Math.floor((cx-rackWidth)/gridSize);
    const cellY = Math.floor(cy/gridSize);
    return {cellX,cellY};
  }

  let active=null;
  function startDrag(e){
    moved=false;
    const {cellX,cellY}=getCellFromEvent(e);
    polys.forEach(poly=>{
      if(poly.contains(cellX,cellY)){
        poly.dragging=true; active=poly;
      }
    });
    e.preventDefault();
  }
  function doDrag(e){
    if(active && active.dragging){
      moved=true;
      const {cellX,cellY}=getCellFromEvent(e);
      active.pos.x=cellX; active.pos.y=cellY;
    }
  }
  function endDrag(e){
    if(active){
      active.dragging=false;
      polys.forEach(poly=>{
        if(poly===active) {
          const overlap = polys.some(o=>o!==poly && poly.getCells().some(c=>o.getCells().some(o2=>o2.x===c.x&&o2.y===c.y)));
          if(overlap){
            const dx = poly.pos.x - poly.lastPos.x;
            const dy = poly.pos.y - poly.lastPos.y;
            poly.pos.x += Math.sign(dx)||0;
            poly.pos.y += Math.sign(dy)||0;
          }
        }
      });
      active.lastPos={...active.pos};
      active=null;
    }
  }

  function handleClick(e){
    if(moved) { moved=false; return; }
    clearTimeout(clickTimer);
    clickTimer = setTimeout(()=>{
      const {cellX,cellY}=getCellFromEvent(e);
      polys.forEach(poly=>{
        if(poly.contains(cellX,cellY)){
          poly.rotate();
        }
      });
    }, 250);
  }
  function handleDblClick(e){
    clearTimeout(clickTimer);
    const {cellX,cellY}=getCellFromEvent(e);
    polys.forEach(poly=>{
      if(poly.contains(cellX,cellY)){
        poly.flip();
      }
    });
  }

  ['mousedown','touchstart'].forEach(evt => canvas.addEventListener(evt, startDrag));
  ['mousemove','touchmove'].forEach(evt => canvas.addEventListener(evt, doDrag));
  ['mouseup','touchend','touchcancel'].forEach(evt => canvas.addEventListener(evt, endDrag));
  canvas.addEventListener('click', handleClick);
  canvas.addEventListener('dblclick', handleDblClick);

  function resize(){
    const uiW = document.querySelector('.slider-container').clientWidth;
    const w = window.innerWidth - uiW;
    const h = window.innerHeight;
    gridSize = Math.floor(Math.min(w/(rackCols+cols), h/rows));
    rackWidth = rackCols*gridSize;
    gridWidth = cols*gridSize;
    gridHeight = rows*gridSize;
    canvas.width = rackWidth + gridWidth;
    canvas.height = gridHeight;
  }
  window.addEventListener('resize', resize);

  function loop(){
    areaValEl.textContent = computeEnclosedArea();
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.strokeStyle = '#ccc';
    for(let x=0;x<=rackWidth;x+=gridSize){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,gridHeight); ctx.stroke(); }
    ctx.strokeStyle = '#000';
    for(let x=rackWidth;x<=rackWidth+gridWidth;x+=gridSize){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,gridHeight); ctx.stroke(); }
    for(let y=0;y<=gridHeight;y+=gridSize){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(rackWidth+gridWidth,y); ctx.stroke(); }
    polys.forEach(p=>p.draw());
    requestAnimationFrame(loop);
  }

  resize();
  resetPieces();
  loop();
</script>
</body>
</html>
