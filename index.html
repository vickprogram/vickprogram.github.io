<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Polyomino Canvas (Mobile)</title>
  <style>
    body { display: flex; margin: 0; font-family: sans-serif; height: 100vh; overflow: hidden; }
    #canvas-container { flex: 1; position: relative; touch-action: none; }
    canvas { background: #fff; display: block; width: 100%; height: 100%; }
    .slider-container { width: 25%; max-width: 300px; padding: 20px; box-sizing: border-box; overflow-y: auto; }
    .slider { margin-bottom: 40px; }
    .label { margin-bottom: 5px; }
  </style>
</head>
<body>
  <div id="canvas-container">
    <canvas id="gameCanvas"></canvas>
  </div>
  <div class="slider-container">
    <div class="slider">
      <div class="label">p (hor leg): <span id="pVal">3</span></div>
      <input type="range" id="sliderP" min="2" max="10" value="3">
    </div>
    <div class="slider">
      <div class="label">q (ver leg): <span id="qVal">2</span></div>
      <input type="range" id="sliderQ" min="2" max="10" value="2">
    </div>
    <div class="slider">
      <div class="label">Pieces: <span id="nVal">4</span></div>
      <input type="range" id="sliderN" min="1" max="40" value="4">
    </div>
    <div>
      <p>Enclosed Area: <span id="areaVal">0</span></p>
      <p>Fully drag pieces into grid</p>
    </div>
  </div>
<script>
// 基本參數
const cols = 30, rows = 30;
const rackCols = 14;
const piecesPerRow = 5;
let gridSize, rackWidth, gridWidth, gridHeight;
let pVal = 3, qVal = 2, nVal = 4;

// DOM 元素
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const sliderP = document.getElementById('sliderP');
const sliderQ = document.getElementById('sliderQ');
const sliderN = document.getElementById('sliderN');
const pValEl = document.getElementById('pVal');
const qValEl = document.getElementById('qVal');
const nValEl = document.getElementById('nVal');
const areaValEl = document.getElementById('areaVal');

// Polyomino 類別
class Polyomino {
  constructor(blocks, color) {
    this.blocks = blocks;
    this.color = color;
    this.pos = { x:0, y:0 };
    this.lastPos = {...this.pos};
    this.dragging = false;
  }
  draw() {
    ctx.fillStyle = this.color;
    ctx.strokeStyle = '#000';
    this.blocks.forEach(({x:bx, y:by}) => {
      const px = this.pos.x < rackCols ? this.pos.x * gridSize : rackWidth + (this.pos.x - rackCols) * gridSize;
      const py = this.pos.y * gridSize;
      ctx.fillRect(px + bx * gridSize, py + by * gridSize, gridSize, gridSize);
      ctx.strokeRect(px + bx * gridSize, py + by * gridSize, gridSize, gridSize);
    });
  }
  contains(x, y) {
    return this.blocks.some(({x:bx, y:by}) => bx + this.pos.x === x && by + this.pos.y === y);
  }
  rotate() {
    let newB = this.blocks.map(({x,y}) => ({x:y, y:-x}));
    const minX = Math.min(...newB.map(b => b.x));
    const minY = Math.min(...newB.map(b => b.y));
    this.blocks = newB.map(b => ({x: b.x - minX, y: b.y - minY}));
  }
  flip() {
    let newB = this.blocks.map(({x,y}) => ({x: -x, y}));
    const minX = Math.min(...newB.map(b => b.x));
    const minY = Math.min(...newB.map(b => b.y));
    this.blocks = newB.map(b => ({x: b.x - minX, y: b.y - minY}));
  }
  getCells() {
    return this.blocks.map(({x,y}) => ({x: this.pos.x + x, y: this.pos.y + y}));
  }
}

// 生成 L 塊
function createL(p, q) {
  const arr = [];
  for(let i = 0; i < p; i++) arr.push({x: i, y: 0});
  for(let j = 1; j < q; j++) arr.push({x: 0, y: j});
  return arr;
}

// 重設拼圖塊
let polys = [];
function resetPieces() {
  polys = [];
  for(let i = 0; i < nVal; i++) {
    const blocks = createL(pVal, qVal);
    const color = `rgb(${100 + Math.random() * 155}, ${100 + Math.random() * 155}, ${100 + Math.random() * 155})`;
    const poly = new Polyomino(blocks, color);
    poly.pos = { x: i % piecesPerRow, y: Math.floor(i / piecesPerRow) };
    poly.lastPos = {...poly.pos};
    polys.push(poly);
  }
}

// 計算包圍面積
function computeEnclosedArea() {
  const grid = Array(rows).fill().map(() => Array(cols).fill(0));
  polys.forEach(poly => poly.getCells().forEach(c => {
    if(c.x >= rackCols && c.x < rackCols + cols && c.y >= 0 && c.y < rows)
      grid[c.y][c.x - rackCols] = 1;
  }));
  const vis = grid.map(r => r.map(() => false));
  const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
  const queue = [];
  // 邊界 flood fill
  for(let x = 0; x < cols; x++){
    if(!grid[0][x]) { vis[0][x] = true; queue.push({x, y: 0}); }
    if(!grid[rows - 1][x]) { vis[rows - 1][x] = true; queue.push({x, y: rows - 1}); }
  }
  for(let y = 0; y < rows; y++){
    if(!grid[y][0]) { vis[y][0] = true; queue.push({x: 0, y}); }
    if(!grid[y][cols - 1]) { vis[y][cols - 1] = true; queue.push({x: cols - 1, y}); }
  }
  while(queue.length) {
    const {x,y} = queue.shift();
    dirs.forEach(([dx,dy]) => {
      const nx = x + dx, ny = y + dy;
      if(nx >= 0 && nx < cols && ny >= 0 && ny < rows && !grid[ny][nx] && !vis[ny][nx]) {
        vis[ny][nx] = true;
        queue.push({x: nx, y: ny});
      }
    });
  }
  let area = 0;
  for(let r = 0; r < rows; r++) for(let c = 0; c < cols; c++) if(!vis[r][c] && !grid[r][c]) area++;
  return area;
}

// 座標轉換
function getCellFromEvent(e) {
  let clientX, clientY;
  if(e.touches && e.touches[0]) { clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; }
  else { clientX = e.clientX; clientY = e.clientY; }
  const rect = canvas.getBoundingClientRect();
  const mx = clientX - rect.left;
  const my = clientY - rect.top;
  const cellX = mx < rackWidth ? Math.floor(mx / gridSize) : rackCols + Math.floor((mx - rackWidth) / gridSize);
  const cellY = Math.floor(my / gridSize);
  return {cellX, cellY};
}

// 調整畫布大小unction resize() {
  const uiWidth = document.querySelector('.slider-container').clientWidth;
  const w = window.innerWidth - uiWidth;
  const h = window.innerHeight;
  gridSize = Math.floor(Math.min(w / (rackCols + cols), h / rows));
  rackWidth = rackCols * gridSize;
  gridWidth = cols * gridSize;
  gridHeight = rows * gridSize;
  canvas.width = rackWidth + gridWidth;
  canvas.height = gridHeight;
}
window.addEventListener('resize', resize);
resize();
resetPieces();

// 滑桿事件
sliderP.addEventListener('input', () => { pVal = +sliderP.value; pValEl.textContent = pVal; resetPieces(); });
sliderQ.addEventListener('input', () => { qVal = +sliderQ.value; qValEl.textContent = qVal; resetPieces(); });
sliderN.addEventListener('input', () => { nVal = +sliderN.value; nValEl.textContent = nVal; resetPieces(); });

// 互動事件
let active = null, moved = false;
let lastTap = 0, clickTimer = null;
const CLICK_DELAY = 250;
canvas.addEventListener('pointerdown', e => {
  e.preventDefault(); moved = false;
  const {cellX,cellY} = getCellFromEvent(e);
  polys.forEach(poly => { if(poly.contains(cellX,cellY)) { poly.dragging = true; active = poly; }});
});
canvas.addEventListener('pointermove', e => {
  if(active && active.dragging) {
    moved = true;
    const {cellX,cellY} = getCellFromEvent(e);
    if(cellX !== active.pos.x || cellY !== active.pos.y) { active.pos.x = cellX; active.pos.y = cellY; }
  }
});
canvas.addEventListener('pointerup', e => {
  e.preventDefault();
  if(active) {
    active.dragging = false;
    // 碰撞回彈
    polys.forEach(other => {
      if(other !== active) {
        active.getCells().forEach(c => {
          other.getCells().forEach(o => {
            if(c.x === o.x && c.y === o.y) {
              const dx = active.lastPos.x - other.lastPos.x;
              const dy = active.lastPos.y - other.lastPos.y;
              active.pos.x = active.lastPos.x + (dx ? Math.sign(dx) : 0);
              active.pos.y = active.lastPos.y + (!dx ? Math.sign(dy) : 0);
            }
          });
        });
      }
    });
    active.lastPos = {...active.pos}; active = null;
  }
  // Tap/Double-Tap 判斷
  const currentTime = Date.now(); const tapLen = currentTime - lastTap;
  const {cellX,cellY} = getCellFromEvent(e);
  if(!moved && tapLen < CLICK_DELAY && tapLen > 0) { clearTimeout(clickTimer); polys.forEach(poly => { if(poly.contains(cellX,cellY)) poly.flip(); }); }
  else if(!moved) { clickTimer = setTimeout(() => { polys.forEach(poly => { if(poly.contains(cellX,cellY)) poly.rotate(); }); }, CLICK_DELAY); }
  lastTap = currentTime;
});

// 繪製迴圈
function loop() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // 繪製格線
  ctx.strokeStyle = '#ccc'; for(let x=0;x<=rackWidth;x+=gridSize){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,gridHeight);ctx.stroke();}
  ctx.strokeStyle = '#000';
  for(let x=rackWidth;x<=rackWidth+gridWidth;x+=gridSize){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,gridHeight);ctx.stroke();}
  for(let y=0;y<=gridHeight;y+=gridSize){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(rackWidth+gridWidth,y);ctx.stroke();}
  polys.forEach(poly=>poly.draw());
  areaValEl.textContent = computeEnclosedArea();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
