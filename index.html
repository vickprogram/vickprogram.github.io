<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Polyomino Canvas</title>
  <style>
    body { display: flex; margin: 0; font-family: sans-serif; height: 100vh; overflow: hidden; }
    #canvas-container { flex: 1; position: relative; }
    canvas { background: #fff; display: block; }
    .slider-container { width: 300px; padding: 20px; box-sizing: border-box; overflow-y: auto; }
    .slider { margin-bottom: 40px; }
    .label { margin-bottom: 5px; }
  </style>
</head>
<body>
  <div id="canvas-container">
    <canvas id="gameCanvas"></canvas>
  </div>
  <div class="slider-container">
    <div class="slider">
      <div class="label">p (hor leg): <span id="pVal">3</span></div>
      <input type="range" id="sliderP" min="2" max="10" value="3">
    </div>
    <div class="slider">
      <div class="label">q (ver leg): <span id="qVal">2</span></div>
      <input type="range" id="sliderQ" min="2" max="10" value="2">
    </div>
    <div class="slider">
      <div class="label">Pieces: <span id="nVal">4</span></div>
      <input type="range" id="sliderN" min="1" max="40" value="4">
    </div>
    <div>
      <p>Enclosed Area: <span id="areaVal">0</span></p>
      <p>Fully drag pieces into grid</p>
    </div>
  </div>
<script>
// Constants
const cols = 30, rows = 30;
const rackCols = 14;
const piecesPerRow = 5;
const uiWidth = 300;

// State
let gridSize, rackWidth, gridWidth, gridHeight;
let pVal = 3, qVal = 2, nVal = 4;

// Canvas & UI refs
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const sliderP = document.getElementById('sliderP');
const sliderQ = document.getElementById('sliderQ');
const sliderN = document.getElementById('sliderN');
const pValEl = document.getElementById('pVal');
const qValEl = document.getElementById('qVal');
const nValEl = document.getElementById('nVal');
const areaValEl = document.getElementById('areaVal');

// Polyomino class
class Polyomino {
  constructor(blocks, color) {
    this.blocks = blocks;
    this.color = color;
    this.pos = { x:0, y:0 };
    this.lastPos = {...this.pos};
    this.dragging = false;
  }
  draw() {
    ctx.fillStyle = this.color;
    ctx.strokeStyle = '#000';
    this.blocks.forEach(({x:bx, y:by}) => {
      const px = this.pos.x < rackCols
                   ? this.pos.x * gridSize
                   : rackWidth + (this.pos.x - rackCols) * gridSize;
      const py = this.pos.y * gridSize;
      ctx.fillRect(px + bx*gridSize, py + by*gridSize, gridSize, gridSize);
      ctx.strokeRect(px + bx*gridSize, py + by*gridSize, gridSize, gridSize);
    });
  }
  contains(x, y) {
    return this.blocks.some(({x:bx, y:by}) => bx + this.pos.x === x && by + this.pos.y === y);
  }
  rotate() {
    let newB = this.blocks.map(({x,y}) => ({x:y, y:-x}));
    const minX = Math.min(...newB.map(b=>b.x));
    const minY = Math.min(...newB.map(b=>b.y));
    this.blocks = newB.map(b => ({x:b.x-minX, y:b.y-minY}));
  }
  flip() {
    let newB = this.blocks.map(({x,y}) => ({x:-x, y}));
    const minX = Math.min(...newB.map(b=>b.x));
    const minY = Math.min(...newB.map(b=>b.y));
    this.blocks = newB.map(b => ({x:b.x-minX, y:b.y-minY}));
  }
  getCells() {
    return this.blocks.map(({x,y}) => ({x:this.pos.x+x, y:this.pos.y+y}));
  }
}

// Functions
function createL(p,q) {
  const arr = [];
  for(let i=0;i<p;i++) arr.push({x:i,y:0});
  for(let j=1;j<q;j++) arr.push({x:0,y:j});
  return arr;
}

let polys = [];
function resetPieces() {
  polys = [];
  for(let i=0;i<nVal;i++){
    const blocks = createL(pVal, qVal);
    const color = `rgb(${100+Math.random()*155},${100+Math.random()*155},${100+Math.random()*155})`;
    const poly = new Polyomino(blocks, color);
    poly.pos = { x:i%piecesPerRow, y:Math.floor(i/piecesPerRow) };
    poly.lastPos = {...poly.pos};
    polys.push(poly);
  }
}

function computeEnclosedArea(){
  const grid = Array(rows).fill().map(()=>Array(cols).fill(0));
  polys.forEach(poly => poly.getCells().forEach(c => {
    if(c.x>=rackCols && c.x<rackCols+cols && c.y>=0 && c.y<rows)
      grid[c.y][c.x-rackCols] = 1;
  }));
  const vis = grid.map(r=>r.map(()=>false));
  const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
  const queue = [];
  // border
  for(let x=0;x<cols;x++){[[0,x],[rows-1,x]].forEach(([y,c])=>{ if(!grid[y][c]&&!vis[y][c]){vis[y][c]=true;queue.push([c,y]);}});}
  for(let y=0;y<rows;y++){[[y,0],[y,cols-1]].forEach(([r,c])=>{ if(!grid[r][c]&&!vis[r][c]){vis[r][c]=true;queue.push([c,r]);}});}
  while(queue.length){ const [cx,cy]=queue.shift(); dirs.forEach(([dx,dy])=>{ const nx=cx+dx, ny=cy+dy; if(nx>=0&&nx<cols&&ny>=0&&ny<rows&&!grid[ny][nx]&&!vis[ny][nx]){vis[ny][nx]=true;queue.push([nx,ny]);}}); }
  return vis.flat().filter((v,i)=>!v && grid[Math.floor(i/cols)][i%cols]===0).length;
}

// Resize handler
function resize(){
  const w = window.innerWidth - uiWidth;
  const h = window.innerHeight;
  gridSize = Math.floor(Math.min(w/(rackCols+cols), h/rows));
  rackWidth = rackCols * gridSize;
  gridWidth = cols * gridSize;
  gridHeight = rows * gridSize;
  canvas.width = rackWidth + gridWidth;
  canvas.height = gridHeight;
}
window.addEventListener('resize', ()=>{ resize(); });
resize();
resetPieces();

// Mouse events
let active=null;
canvas.addEventListener('mousedown', e=>{
  const rect=canvas.getBoundingClientRect();
  const mx=e.clientX-rect.left;
  const my=e.clientY-rect.top;
  const cellX = mx<rackWidth? Math.floor(mx/gridSize): rackCols+Math.floor((mx-rackWidth)/gridSize);
  const cellY = Math.floor(my/gridSize);
  polys.forEach(poly=>{
    if(poly.contains(cellX, cellY)){
      if(e.button===0){ poly.dragging=true; active=poly; }
      if(e.button===2) poly.rotate();
      if(e.button===1) poly.flip();
    }
  });
});
canvas.addEventListener('mousemove', e=>{
  if(active&&active.dragging){
    const rect=canvas.getBoundingClientRect();
    const mx=e.clientX-rect.left;
    const my=e.clientY-rect.top;
    active.pos.x = mx<rackWidth? Math.floor(mx/gridSize): rackCols+Math.floor((mx-rackWidth)/gridSize);
    active.pos.y = Math.floor(my/gridSize);
  }
});
canvas.addEventListener('mouseup', ()=>{ if(active) active.dragging=false; active=null; });
canvas.addEventListener('contextmenu', e=>e.preventDefault());

// Main loop
function loop(){
  // update UI
  if(pVal!==+sliderP.value||qVal!==+sliderQ.value||nVal!==+sliderN.value){
    pVal=+sliderP.value; qVal=+sliderQ.value; nVal=+sliderN.value;
    pValEl.textContent=pVal; qValEl.textContent=qVal; nValEl.textContent=nVal;
    resetPieces();
  }
  // collision revert
  polys.forEach(poly=>{
    const overlap = polys.some(o=>o!==poly && poly.getCells().some(c=>o.getCells().some(o2=>o2.x===c.x&&o2.y===c.y)));
    if(overlap) poly.pos={...poly.lastPos}; else poly.lastPos={...poly.pos};
  });

  ctx.clearRect(0,0,canvas.width,canvas.height);
  // draw rack+grid lines
  ctx.strokeStyle='#ccc'; for(let x=0;x<=rackWidth;x+=gridSize){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,gridHeight);ctx.stroke();}
  ctx.strokeStyle='#000'; for(let x=rackWidth;x<=rackWidth+gridWidth;x+=gridSize){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,gridHeight);ctx.stroke();}
  for(let y=0;y<=gridHeight;y+=gridSize){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(rackWidth+gridWidth,y);ctx.stroke();}

  polys.forEach(poly=>poly.draw());
  areaValEl.textContent=computeEnclosedArea();

  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
